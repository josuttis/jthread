%!TEX root = std.tex
\setcounter{chapter}{29}
\rSec0[thread]{Thread support library}

%******************************************************************
\rSec1[jthread.general]{General}

\pnum
The following subclauses describe components to create and manage
threads\iref{intro.multithread}, perform mutual exclusion, and communicate conditions
and values
between threads, as summarized in \tref{thread.lib.summary}.

\begin{libsumtab}{Thread support library summary}{tab:thread.lib.summary}
\ref{thread.req}      & Requirements          &                               \\ \rowsep
\ref{thread.threads}  & Threads               & \tcode{<thread>}              \\ \rowsep
\color{insertcolor}
\ref{thread.stop_token} &
        \color{insertcolor} Stop Tokens       &
                \color{insertcolor} \tcode{<stop_token>}              \\ \rowsep
\color{insertcolor}
\ref{thread.jthreads} &
        \color{insertcolor} Joining Threads       &
                \color{insertcolor} \tcode{<jthread>}              \\ \rowsep
\ref{thread.mutex}    & Mutual exclusion      & \tcode{<mutex>}               \\
                      &                       & \tcode{<shared_mutex>}        \\ \rowsep
\ref{thread.condition}& Condition variables   & \tcode{<condition_variable>}  \\ \rowsep
\ref{futures}         & Futures               & \tcode{<future>}              \\
\end{libsumtab}

%******************************************************************
\rSec1[thread.req]{Requirements}

...

%******************************************************************
\rSec1[thread.threads]{Threads}

...

\clearpage

{\color{insertcolor}

%******************************************************************
\rSec1[thread.stop_token]{Stop Tokens}

\pnum
\ref{thread.stop_token} describes components that can be used to
asynchonously request that an operation stop execution in a timely
manner, typically because the result is no longer required.

\pnum
A \tcode{stop_token} can be passed to an operation which can either
actively poll the token to check if there has been a request to stop
or can register a callback using the \tcode{stop_callback} class which
will be called in the event that a request to stop is made. A request
to stop can be made via any one of potentially multiple associated
\tcode{stop_source}s and this request will be visible to all associated
\tcode{stop_token}s. Once a request to stop has been made it cannot be
withdrawn (second and subsequent requests to stop have no effect).

\pnum
Callbacks registered via a \tcode{stop_callback} object are called when
a request to stop is first made by any of the \tcode{stop_source} objects
associated with the \tcode{stop_token} used to construct the \tcode{stop_callback}.

\pnum
To support this, classes \tcode{stop_source}, \tcode{stop_token}, and \tcode{stop_callback}
implement semantics of shared ownership of an associated shared stop state.
The last remaining owner of the stop state automatically 
releases the resources associated with the stop state.

\pnum
Potentially concurrent calls to \tcode{request_stop()}, \tcode{stop_requested()},
and \tcode{stop_possible()}
do not introduce data races. 
A call to \tcode{request_stop()} that returns \tcode{false} (i.e. the first call)
synchronizes with a call to \tcode{stop_requested()} on an associated \tcode{stop_token}
or \tcode{stop_source} that returns \tcode{true}.

%**************************
\rSec2[thread.stop_token.syn]{Header \tcode{<stop_token>} synopsis}
\indexhdr{stop_token}%

\begin{codeblock}
namespace std {
  // \ref{stop_callback} class \tcode{stop_callback}
  template <Invocable Callback>
    requires Destructible<Callback>
  class stop_callback;
  // \ref{stop_source} class \tcode{stop_source}
  class stop_source;
  // \ref{stop_token} class \tcode{stop_token}
  class stop_token;
}
\end{codeblock}


%**************************
% stop_callback
%**************************
\indexlibrary{\idxcode{stop_callback}}%
\rSec2[stop_callback]{Class \tcode{stop_callback}}

\pnum
\indexlibrary{\idxcode{stop_callback}}%

\begin{codeblock}
namespace std {
  template <Invocable Callback>
    requires Destructible<Callback>
  class stop_callback {
  public:
    // \ref{stop_callback.constr} create, destroy:
    template <typename C>
        requires Constructible<Callback, C>
    explicit stop_callback(const stop_token& st, C&& cb)
        noexcept(std::is_nothrow_constructible_v<Callback, C>);
    template <typename C>
        requires Constructible<Callback, C>
    explicit stop_callback(stop_token&& st, C&& cb)
        noexcept(std::is_nothrow_constructible_v<Callback, C>);
    ~stop_callback();

    stop_callback(const stop_callback&) = delete;
    stop_callback(stop_callback&&) = delete;
    stop_callback& operator=(const stop_callback&) = delete;
    stop_callback& operator=(stop_callback&&) = delete;

  private:
    // \expos
    Callback callback; 
  };

  template <typename Callback>
  stop_callback(stop_token, Callback) -> stop_callback<Callback>;
}
\end{codeblock}

%*****
\rSec3[stop_callback.constr]{\tcode{stop_callback} constructors and destructor}

\indexlibrary{\idxcode{stop_callback}!constructor}%
\begin{itemdecl}
template <typename C>
  requires Constructible<Callback, C>
explicit stop_callback(const stop_token& st, C&& cb)
  noexcept(std::is_nothrow_constructible_v<Callback, C>);
template <typename C>
  requires Constructible<Callback, C>
explicit stop_callback(stop_token&& st, C&& cb)
  noexcept(std::is_nothrow_constructible_v<Callback, C>);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Initialises \tcode{callback} with \tcode{static_cast<C\&\&>(cb)}.
                If \tcode{st.stop_requested()} is \tcode{true} then immediately invokes
                \tcode{static_cast<Callback\&\&>(callback)}
                with zero arguments in the current thread before the constructor returns.
                Otherwise, the callback is registered with the shared stop state of \tcode{st}
                such that \tcode{static_cast<Callback\&\&>(callback)} is invoked by the first call to \tcode{src.request_stop()}
                on any \tcode{stop_source} instance \tcode{src} that references the same shared stop
                state as \tcode{st}.
                If invoking the callback throws an unhandled exception then \tcode{std::terminate()} is called.

  \pnum\throws Any exception thrown by the initialization of \tcode{callback}.
\end{itemdescr}

\indexlibrary{\idxcode{stop_callback}!destructor}%
\begin{itemdecl}
~stop_callback();
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Unregisters the callback from the associated shared stop state.
                The destructor does not block waiting for the execution of another callback registered
                with the same shared stop state to finish.
                If \tcode{callback} is concurrently executing on another thread then the return
                from the invocation of \tcode{callback} will strongly happen before 
                \tcode{callback} is destroyed.
                If \tcode{~stop_callback()} is invoked while the invocation of \tcode{callback}
                is active on the current thread then the destructor does not block waiting
                for the return from \tcode{callback}.
\end{itemdescr}

%**************************
% stop_source
%**************************
\indexlibrary{\idxcode{stop_source}}%
\rSec2[stop_source]{Class \tcode{stop_source}}

\pnum
\indexlibrary{\idxcode{stop_source}}%
The class \tcode{stop_source} implements the semantics of signaling a request to stop
to \tcode{stop_token}s (\ref{stop_token}) sharing the same shared stop state.
All \tcode{stop_source}s sharing the same shared stop state can request to stop.
Once a request to stop has been made it cannot be undone.
A subsequent request to stop has no effect.

\begin{codeblock}
namespace std {
  // \ref{stop_source.nostopstate} no-shared-stop-state indicator
  struct nostopstate_t{@\seebelow@};
  inline constexpr nostopstate_t nostopstate(@\unspec@);

  class stop_source {
  public:
    // \ref{stop_source.constr} create, copy, destroy:
    stop_source();
    explicit stop_source(nostopstate_t) noexcept;

    stop_source(const stop_source&) noexcept;
    stop_source(stop_source&&) noexcept;
    stop_source& operator=(const stop_source&) noexcept;
    stop_source& operator=(stop_source&&) noexcept;
    ~stop_source();
    void swap(stop_source&) noexcept;

    // \ref{stop_source.mem} stop handling:
    [[nodiscard]] stop_token get_token() const noexcept;
    [[nodiscard]] bool stop_possible() const noexcept;
    [[nodiscard]] bool stop_requested() const noexcept;
    bool request_stop() noexcept;

    [[nodiscard]] friend bool operator== (const stop_source& lhs, const stop_source& rhs) noexcept;
    [[nodiscard]] friend bool operator!= (const stop_source& lhs, const stop_source& rhs) noexcept;
  };
}
\end{codeblock}

%***** nostopstate_t
\rSec3[stop_source.nostopstate]{No-shared-stop-state indicator}

\indexlibrary{\idxcode{nostopstate_t}}%
\indexlibrary{\idxcode{nostopstate}}%
\begin{itemdecl}
struct nostopstate_t{@\seebelow@};
inline constexpr nostopstate_t nostopstate(@\unspec@);
\end{itemdecl}

\pnum
The struct \tcode{nostopstate_t} is an empty class type used as a unique type to indicate the state of
not containing a shared stop state for \tcode{stop_source} objects.
In particular, \tcode{stop_source} has a constructor with \tcode{nostopstate_t} as a single argument;
this indicates that a \tcode{stop_source} object not sharing a stop state shall be constructed.

\pnum
Type \tcode{nostopstate_t} shall not have a default constructor or an initializer-list constructor, and shall not be an aggregate.

%***** constructors
\rSec3[stop_source.constr]{\tcode{stop_source} constructors}

\indexlibrary{\idxcode{stop_source}!constructor}%
\begin{itemdecl}
stop_source();
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Constructs a new \tcode{stop_source} object that can be used to request stops.
  
  \pnum\postconditions \tcode{stop_possible() == true} and \tcode{stop_requested() == false}.

  \pnum\throws \tcode{bad_alloc} if memory could not be allocated for the shared stop state.
\end{itemdescr}

\indexlibrary{\idxcode{stop_source}!constructor}%
\begin{itemdecl}
explicit stop_source(nostopstate_t) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Constructs a new \tcode{stop_source} object that can't be used to request stops.
                \begin{note} Therefore, no resources have to be associated for the state.  \end{note}

  \pnum\postconditions \tcode{stop_possible() == false}.
\end{itemdescr}

%*** special members:

\indexlibrary{\idxcode{stop_source}!constructor}%
\begin{itemdecl}
stop_source(const stop_source& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects If \tcode{rhs.stop_possible() == true},
                constructs a \tcode{stop_source}
                that shares the ownership of the stop state with \tcode{rhs}.

  % TODO: It's possible that evaluating stop_requested() == rhs.stop_requested()
  %       could return 'false' if another thread concurrently called request_stop().
  %       Is this a problem putting it in in a post-condition?
  \pnum\postconditions \tcode{stop_possible() == rhs.stop_possible()}
                and \tcode{stop_requested() == rhs.stop_requested()}
                and \tcode{*this == rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{stop_source}!constructor}%
\begin{itemdecl}
stop_source(stop_source&& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Move constructs an object of type \tcode{stop_source} from \tcode{rhs}.

  \pnum\postconditions \tcode{*this} shall contain the old value of \tcode{rhs} and
                        \tcode{rhs.stop_possible() == false}.
\end{itemdescr}

%*****
\rSec3[stop_source.destr]{\tcode{stop_source} destructor}

\indexlibrary{\idxcode{stop_source}!destructor}%
\begin{itemdecl}
~stop_source();
\end{itemdecl}

\begin{itemdescr}
 \pnum\effects If \tcode{stop_possible()} and \tcode{*this} is the last owner of the stop state,
                releases the resources associated with the stop state.
\end{itemdescr}

%*****
\rSec3[stop_source.assign]{\tcode{stop_source} assignment}

\indexlibrarymember{operator=}{stop_source}%
\begin{itemdecl}
stop_source& operator=(const stop_source& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Equivalent to: \tcode{stop_source(rhs).swap(*this);}

  \pnum\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{stop_source}%
\begin{itemdecl}
stop_source& operator=(stop_source&& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Equivalent to: \tcode{stop_source(std::move(rhs)).swap(*this);}

  \pnum\returns \tcode{*this}.
\end{itemdescr}

%*****
\rSec3[stop_source.swap]{\tcode{stop_source} swap}

\indexlibrarymember{swap}{stop_source}%
\begin{itemdecl}
void swap(stop_source& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
 \pnum \effects Swaps the state of \tcode{*this} and \tcode{rhs}.
\end{itemdescr}


%***** get_token()
\rSec3[stop_source.mem]{\tcode{stop_source} members}

\indexlibrarymember{get_token}{stop_source}%
\begin{itemdecl}
[[nodiscard]] stop_token get_token() const noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects If \tcode{!stop_possible()}, constructs a \tcode{stop_token} object
                that does not share a stop state.
                Otherwise, constructs a \tcode{stop_token} object \tcode{st}
                that shares the ownership of the stop state with \tcode{*this}.

  \pnum\postconditions \tcode{stop_possible() == st.stop_possible()}
                and \tcode{stop_requested() == st.stop_requested()}.
\end{itemdescr}


\indexlibrarymember{stop_possible}{stop_source}%
\begin{itemdecl}
[[nodiscard]] bool stop_possible() const noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \tcode{true} if the stop source can be used to request stops, executed atomically.
                \begin{note} Returns \tcode{false} if the object was created with \tcode{nostopstate}
                             or the values were moved away.
                             \end{note}
\end{itemdescr}

\indexlibrarymember{stop_requested}{stop_source}%
\begin{itemdecl}
[[nodiscard]] bool stop_requested() const noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \tcode{true} if \tcode{stop_possible()} 
                and \tcode{request_stop()} was called by one of the owners, executed atomically.
\end{itemdescr}

\indexlibrarymember{request_stop}{stop_source}%
\begin{itemdecl}
bool request_stop() noexcept;
\end{itemdecl}
\begin{itemdescr}
  %\pnum\requires \tcode{stop_possible() == true}
  %Hans:
  %Did we discuss whether interrupt() on an invalid (e.g. default constructed) stop/interrupt token should be a no-op,
  %rather than undefined? I would expect that to be convenient if we start passing stop_tokens around explicitly.
  %Presumably a lot of short-lived tasks don't care about stopping/interruption, but might be used in a context in which an
  %stop/interrupt token is expected. With the change, you could just pass a default-constructed one.

  \pnum\effects If \tcode{!stop_possible()} or \tcode{stop_requested()} the call has no effect. 
                Otherwise, atomically requests to stop so that \tcode{stop_requested() == true}
                and all registered callbacks are synchronously called.
                \begin{note} Requesting to stop includes notifying all condition variables
                             of type \tcode{condition_variable_any}
                             temporarily registered during an interruptable wait (\ref{thread.condition.stop_source})
                             \end{note}

  \pnum\postconditions \tcode{!stop_possible() || stop_requested()}

  \pnum\returns The value of \tcode{stop_requested()} prior to the call.
\end{itemdescr}


%*****
\rSec3[stop_source.cmp]{\tcode{stop_source} comparisons}

\indexlibrarymember{operator==}{stop_source}%
\begin{itemdecl}
[[nodiscard]] bool operator== (const stop_source& lhs, const stop_source& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \tcode{true} if \tcode{!lhs.stop_possible() \&\& !rhs.stop_possible()},
                \tcode{true} if \tcode{lhs} and \tcode{rhs} share ownership
                of the same stop state
                (copied or moved from the same initial \tcode{stop_source} object),
                otherwise \tcode{false}.
\end{itemdescr}

\indexlibrarymember{operator!=}{stop_source}%
\begin{itemdecl}
[[nodiscard]] bool operator!= (const stop_source& lhs, const stop_source& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \tcode{!(lhs==rhs)}.
\end{itemdescr}


%**************************
% stop_token
%**************************
\indexlibrary{\idxcode{stop_token}}%
\rSec2[stop_token]{Class \tcode{stop_token}}

\pnum
\indexlibrary{\idxcode{stop_token}}%
The class \tcode{stop_token} provides an interface for querying whether
a request to stop has been made (\tcode{stop_requested()}) or can ever be made
(\tcode{stop_possible()}) from an associated \tcode{stop_source} object.
A \tcode{stop_token} can also be passed to a \tcode{stop_callback} constructor
to register a callback to be called when a request to stop has been made from
an associated \tcode{stop_source}. 

\begin{codeblock}
namespace std {
  class stop_token {
  public:
    // \ref{stop_token.constr} create, copy, destroy:
    stop_token() noexcept;

    stop_token(const stop_token&) noexcept;
    stop_token(stop_token&&) noexcept;
    stop_token& operator=(const stop_token&) noexcept;
    stop_token& operator=(stop_token&&) noexcept;
    ~stop_token();
    void swap(stop_token&) noexcept;

    // \ref{stop_token.mem} stop handling:
    [[nodiscard]] bool stop_requested() const noexcept;
    [[nodiscard]] bool stop_possible() const noexcept;

    [[nodiscard]] friend bool operator== (const stop_token& lhs, const stop_token& rhs) noexcept;
    [[nodiscard]] friend bool operator!= (const stop_token& lhs, const stop_token& rhs) noexcept;
  };
}
\end{codeblock}


%*****
\rSec3[stop_token.constr]{\tcode{stop_token} constructors}

\indexlibrary{\idxcode{stop_token}!constructor}%
\begin{itemdecl}
stop_token() noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Constructs a new \tcode{stop_token} object that can never receive a request to stop.
                \begin{note} Therefore, no resources have to be associated for the state. \end{note}

  \pnum\postconditions \tcode{stop_possible() == false} and 
                       \tcode{stop_requested() == false}.
\end{itemdescr}

%***** special members:

\indexlibrary{\idxcode{stop_token}!constructor}%
\begin{itemdecl}
stop_token(const stop_token& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  % The 'effects' here seem in conflict with the requirement that *this == rhs is a post-condition.
  \pnum\effects If \tcode{rhs.stop_possible() == false}, constructs a \tcode{stop_token} object
                that can never receive a request to stop.
                Otherwise, constructs a \tcode{stop_token}
                that shares the ownership of the stop state with \tcode{rhs}.

  \pnum\postconditions \tcode{stop_possible() == rhs.stop_possible()}
                and \tcode{stop_requested() == rhs.stop_requested()}
                and \tcode{*this == rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{stop_token}!constructor}%
\begin{itemdecl}
stop_token(stop_token&& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Move constructs an object of type \tcode{stop_token} from \tcode{rhs}.

  \pnum\postconditions \tcode{*this} shall contain the old value of \tcode{rhs} and
                        \tcode{rhs.stop_possible() == false}.
\end{itemdescr}

%*****
\rSec3[stop_token.destr]{\tcode{stop_token} destructor}

\indexlibrary{\idxcode{stop_token}!destructor}%
\begin{itemdecl}
~stop_token();
\end{itemdecl}

\begin{itemdescr}
 \pnum\effects If \tcode{*this} is the last owner of the shared stop state,
                releases the resources associated with the shared stop state.
\end{itemdescr}

%*****
\rSec3[stop_token.assign]{\tcode{stop_token} assignment}

\indexlibrarymember{operator=}{stop_token}%
\begin{itemdecl}
stop_token& operator=(const stop_token& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Equivalent to: \tcode{stop_token(rhs).swap(*this);}

  \pnum\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{stop_token}%
\begin{itemdecl}
stop_token& operator=(stop_token&& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Equivalent to: \tcode{stop_token(std::move(rhs)).swap(*this);}

  \pnum\returns \tcode{*this}.
\end{itemdescr}

%*****
\rSec3[stop_token.swap]{\tcode{stop_token} swap}

\indexlibrarymember{swap}{stop_token}%
\begin{itemdecl}
void swap(stop_token& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Swaps the state of \tcode{*this} and \tcode{rhs}.
\end{itemdescr}


%*****
\rSec3[stop_token.mem]{\tcode{stop_token} members}

\indexlibrarymember{stop_requested}{stop_token}%
\begin{itemdecl}
[[nodiscard]] bool stop_requested() const noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \tcode{true} if \tcode{request_stop()} was called on an
                associated \tcode{stop_source},
                otherwise \tcode{false}, executed atomically.

  \pnum\sync If \tcode{true} is returned then synchronizes with the
             first call to \tcode{request_stop()} on an associated
             \tcode{stop_source}.
\end{itemdescr}

\indexlibrarymember{stop_possible}{stop_token}%
\begin{itemdecl}
[[nodiscard]] bool stop_possible() const noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \tcode{false} if a subsequent call to \tcode{stop_requested()} will never return \tcode{true},
                otherwise \tcode{true}, executed atomically.
                \begin{note}To retuurn \tcode{true} either a call to \tcode{request_stop()}
                  on an associated \tcode{stop_source} must have already been made or there
                  must still be associated \tcode{stop_source} objects in existence on which
                  a call to \tcode{request_stop()} could potentially be made in future.
                \end{note}
\end{itemdescr}


%*****
\rSec3[stop_token.cmp]{\tcode{stop_token} comparisons}

\indexlibrarymember{operator==}{stop_token}%
\begin{itemdecl}
[[nodiscard]] bool operator== (const stop_token& lhs, const stop_token& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \tcode{true} if \tcode{!lhs.stop_possible() \&\& !rhs.stop_possible()},
                \tcode{true} if \tcode{lhs} and \tcode{rhs} share ownership
                of the same stop state
                (copied or moved from the same initial \tcode{stop_source} object),
                otherwise \tcode{false}.
\end{itemdescr}

\indexlibrarymember{operator!=}{stop_token}%
\begin{itemdecl}
[[nodiscard]] bool operator!= (const stop_token& lhs, const stop_token& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \tcode{!(lhs==rhs)}.
\end{itemdescr}


\clearpage

%******************************************************************
\rSec1[thread.jthreads]{Joining Threads}

\pnum
\ref{thread.jthreads} describes components that can be used to create and manage threads
with the ability to
cooperatively cancel the running thread, by requesting it to stop.

%**************************
\rSec2[thread.jthread.syn]{Header \tcode{<jthread>} synopsis}
\indexhdr{jthread}%

\begin{codeblock}
#include <stop_token>

namespace std {
  // \ref{thread.jthread.class} class \tcode{jthread}
  class jthread;

  void swap(jthread& x, jthread& y) noexcept;
}
\end{codeblock}


%**************************
\rSec2[thread.jthread.class]{Class \tcode{jthread}}

\pnum
The class \tcode{jthread} provides a mechanism
to create a new thread of execution.
The functionality is the same as for class \tcode{thread} (\ref{thread.thread.class})
with the additional ability to request that the thread stop and to
automatically \tcode{join()} the started thread.

{\color{blue}
[{\itshape{}Editorial note:} {\color{diffcolor}This color signals differences to class \tcode{std::thread}.} ]
}

\indexlibrary{\idxcode{jthread}}%
\begin{codeblock}
namespace std {
  class jthread {
  public:
    // types
    using id = thread::id;
    using native_handle_type = thread::native_handle_type;

    // construct/copy/destroy
    jthread() noexcept;
    template<class F, class... Args> explicit jthread(F&& f, Args&&... args);
    ~jthread();
    jthread(const jthread&) = delete;
    jthread(jthread&&) noexcept;
    jthread& operator=(const jthread&) = delete;
    jthread& operator=(jthread&&) noexcept;

    // members
    void swap(jthread&) noexcept;
    bool joinable() const noexcept;
    void join();
    void detach();
    [[nodiscard]] id get_id() const noexcept;
    [[nodiscard]] native_handle_type native_handle();     // see~\ref{thread.req.native}
\end{codeblock}
{\color{diffcolor}
\begin{codeblock}
    // stop token handling
    [[nodiscard]] stop_source get_stop_source() noexcept;
    [[nodiscard]] stop_token get_stop_token() const noexcept;
    bool request_stop() noexcept;
\end{codeblock}
}%\color{diffcolor}
\begin{codeblock}
    // static members
    [[nodiscard]] static unsigned int hardware_concurrency() noexcept;
  
\end{codeblock}
{\color{diffcolor}
\begin{codeblock}
  private:
    stop_source ssource;                 // \expos
  };
\end{codeblock}
}%\color{diffcolor}
\begin{codeblock}
}
\end{codeblock}


\rSec3[thread.jthread.constr]{\tcode{jthread} constructors}

\indexlibrary{\idxcode{jthread}!constructor}%
\begin{itemdecl}
jthread() noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Constructs a \tcode{jthread} object that does not represent a thread of execution.

  \pnum\postconditions \tcode{get_id() == id()}
        {\color{diffcolor} and \tcode{ssource.stop_possible() == false}}.
\end{itemdescr}

\indexlibrary{\idxcode{jthread}!constructor}%
\begin{itemdecl}
template<class F, class... Args> explicit jthread(F&& f, Args&&... args);
\end{itemdecl}
\begin{itemdescr}
  \pnum
\requires\ \tcode{F} and each $\tcode{T}_i$ in \tcode{Args} shall satisfy the
\oldconcept{MoveConstructible} requirements.
{\color{diffcolor}
        \tcode{%
                \placeholdernc{INVOKE}(\brk{}%
                \placeholdernc{DECAY_COPY}(\brk{}%
                std::forward<F>(f)),
                ssource.get_token(),
                \placeholdernc{DECAY_COPY}(\brk{}%
                std::forward<Args>(\brk{}args))...)}
        or
}
        \tcode{%
                \placeholdernc{INVOKE}(\brk{}%
                \placeholdernc{DECAY_COPY}(\brk{}%
                std::forward<F>(f)),
                \placeholdernc{DECAY_COPY}(\brk{}%
                std::forward<Args>(\brk{}args))...)}
\iref{func.require} shall be a valid expression.

\pnum\remarks
This constructor shall not participate in overload resolution if \tcode{remove_cvref_t<F>}
is the same type as \tcode{std::jthread}.

\pnum\effects
{\color{diffcolor} Initializes \tcode{ssource} and
}
constructs an object of type \tcode{jthread}.
The new thread of execution executes
{\color{diffcolor}
        \tcode{%
                \placeholdernc{INVOKE}(\brk{}%
                \placeholdernc{DECAY_COPY}(\brk{}%
                std::forward<F>(f)),
                ssource.get_token(),
                \placeholdernc{DECAY_COPY}(\brk{}%
                std::forward<Args>(\brk{}args))...)}
if that expression is well-formed,
otherwise
}
        \tcode{%
                \placeholdernc{INVOKE}(\brk{}%
                \placeholdernc{DECAY_COPY}(\brk{}%
                std::forward<F>(f)),
                \placeholdernc{DECAY_COPY}(\brk{}%
                std::forward<Args>(\brk{}args))...)}
with the calls to
\tcode{\placeholder{DECAY_COPY}} being evaluated in the constructing thread.
Any return value from this invocation is ignored.
\begin{note} This implies that any exceptions not thrown from the invocation of the copy
of \tcode{f} will be thrown in the constructing thread, not the new thread. \end{note}
If the invocation
with \tcode{\placeholdernc{INVOKE}()}
%of
%\tcode{%
%\placeholdernc{INVOKE}(\brk{}%
%\placeholdernc{DECAY_COPY}(\brk{}%
%std::forward<F>(f)),
%\placeholdernc{DECAY_COPY}(\brk{}%
%std::forward<Args>(args))...)}
terminates with an uncaught exception, \tcode{terminate()} shall be called.

\pnum\sync The completion of the invocation of the constructor
synchronizes with the beginning of the invocation of the copy of \tcode{f}.

\pnum\postconditions \tcode{get_id() != id()}.
{\color{diffcolor}
                     \tcode{ssource.stop_possible() == true}.
}
                     \tcode{*this} represents the newly started thread.
{\color{diffcolor}
\begin{note} Note that the calling thread can request to stop only once,
                because it can't replace this stop token.  \end{note}
}%\color{diffcolor}

\pnum\throws \tcode{system_error} if unable to start the new thread.

\pnum\errors
\begin{itemize}
\item \tcode{resource_unavailable_try_again} --- the system lacked the necessary
resources to create another thread, or the system-imposed limit on the number of
threads in a process would be exceeded.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{jthread}!constructor}%
\begin{itemdecl}
jthread(jthread&& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an object of type \tcode{jthread} from \tcode{x}, and sets
\tcode{x} to a default constructed state.

\pnum
\postconditions \tcode{x.get_id() == id()} and \tcode{get_id()} returns the
value of \tcode{x.get_id()} prior to the start of construction.
{\color{diffcolor}
\tcode{ssource} yields the value of \tcode{x.ssource} prior to the start of construction
and \tcode{x.ssource.stop_possible() == false}.
}%\color{diffcolor}

\end{itemdescr}

\rSec3[thread.jthread.destr]{\tcode{jthread} destructor}

\indexlibrary{\idxcode{jthread}!destructor}%
\begin{itemdecl}
~jthread();
\end{itemdecl}

{\color{diffcolor}
\begin{itemdescr}
\pnum
If \tcode{joinable()}, calls \tcode{request_stop()} and \tcode{join()}.
Otherwise, has no effects.
\begin{note} Operations on \tcode{*this} are not synchronized. \end{note}
\end{itemdescr}
}%\color{diffcolor}

\rSec3[thread.jthread.assign]{\tcode{jthread} assignment}

\indexlibrarymember{operator=}{jthread}%
\begin{itemdecl}
jthread& operator=(jthread&& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{joinable()}, calls \tcode{request_stop()} and \tcode{join()}.
Assigns the
state of \tcode{x} to \tcode{*this} and sets \tcode{x} to a default constructed state.

{\color{diffcolor}
\pnum
\postconditions \tcode{x.get_id() == id()} and \tcode{get_id()} returns the value of
\tcode{x.get_id()} prior to the assignment.
\tcode{ssource} yields the value of \tcode{x.ssource} prior to the assignment
and \tcode{x.ssource.stop_possible() == false}.
}%\color{diffcolor}

\pnum
\returns \tcode{*this}.
\end{itemdescr}


\rSec3[thread.jthread.stop]{\tcode{jthread} stop members}

{\color{diffcolor}
\indexlibrarymember{get_stop_source}{jthread}%
\begin{itemdecl}
[[nodiscard]] stop_source get_stop_source() noexcept
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Equivalent to: \tcode{return ssource;}
\end{itemdescr}

\indexlibrarymember{get_stop_token}{jthread}%
\begin{itemdecl}
[[nodiscard]] stop_token get_stop_token() const noexcept
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Equivalent to: \tcode{return ssource.get_token();}
\end{itemdescr}

\indexlibrarymember{request_stop}{jthread}%
\begin{itemdecl}
bool request_stop() noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Equivalent to: \tcode{return ssource.request_stop();}
\end{itemdescr}
}%\color{diffcolor}

%\rSec3[thread.jthread.static]{\tcode{jthread} static members}
%
%\indexlibrarymember{hardware_concurrency}{thread}%
%\begin{itemdecl}
%unsigned hardware_concurrency() noexcept;
%\end{itemdecl}
%\begin{itemdescr}
%  \pnum\effects Equivalent to: \tcode{return thread::hardware_concurrency()}.
%\end{itemdescr}
%
%\rSec3[thread.jthread.algorithm]{\tcode{jthread} specialized algorithms}
%
%\indexlibrarymember{swap}{jthread}%
%\begin{itemdecl}
%void swap(jthread& x, jthread& y) noexcept;
%\end{itemdecl}
%\begin{itemdescr}
%  \pnum\effects As if by \tcode{x.swap(y)}.
%\end{itemdescr}

}%\color{insertcolor}


\clearpage

%******************************************************************
\rSec1[thread.mutex]{Mutual exclusion}

...

%******************************************************************
\rSec1[thread.condition]{Condition variables}

...

\rSec2[condition_variable.syn]{Header \tcode{<condition_variable>} synopsis}

...

\rSec2[thread.condition.nonmember]{Non-member functions}

...

\rSec2[thread.condition.condvar]{Class \tcode{condition_variable}}

...

\rSec2[thread.condition.condvarany]{Class \tcode{condition_variable_any}}

...

\indexlibrary{\idxcode{condition_variable_any}}%
\begin{codeblock}
namespace std {
  class condition_variable_any {
  public:
    condition_variable_any();
    ~condition_variable_any();

    condition_variable_any(const condition_variable_any&) = delete;
    condition_variable_any& operator=(const condition_variable_any&) = delete;

    void notify_one() noexcept;
    void notify_all() noexcept;

\end{codeblock}
{\color{insertcolor}
\begin{codeblock}
    // \ref{thread.condvarany.wait} noninterruptable waits:
\end{codeblock}
}%insertcolor
\begin{codeblock}
    template<class Lock>
      void wait(Lock& lock);
    template<class Lock, class Predicate>
      void wait(Lock& lock, Predicate pred);

    template<class Lock, class Clock, class Duration>
      cv_status wait_until(Lock& lock, const chrono::time_point<Clock, Duration>& abs_time);
    template<class Lock, class Clock, class Duration, class Predicate>
      bool wait_until(Lock& lock, const chrono::time_point<Clock, Duration>& abs_time,
                      Predicate pred);
    template<class Lock, class Rep, class Period>
      cv_status wait_for(Lock& lock, const chrono::duration<Rep, Period>& rel_time);
    template<class Lock, class Rep, class Period, class Predicate>
      bool wait_for(Lock& lock, const chrono::duration<Rep, Period>& rel_time, Predicate pred);

\end{codeblock}
{\color{insertcolor}
\begin{codeblock}
    // \ref{thread.condvarany.interruptwait} \tcode{stop_token} waits:
    template <class Lock, class Predicate>
      bool wait_until(Lock& lock,
                      Predicate pred,
                      stop_token stoken);
    template <class Lock, class Clock, class Duration, class Predicate>
      bool wait_until(Lock& lock,
                      const chrono::time_point<Clock, Duration>& abs_time
                      Predicate pred,
                      stop_token stoken);
    template <class Lock, class Rep, class Period, class Predicate>
      bool wait_for(Lock& lock,
                    const chrono::duration<Rep, Period>& rel_time,
                    Predicate pred,
                    stop_token stoken);
\end{codeblock}
}
\begin{codeblock}
  };
}
\end{codeblock}


\indexlibrary{\idxcode{condition_variable_any}!constructor}%
\begin{itemdecl}
condition_variable_any();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an object of type \tcode{condition_variable_any}.

\pnum
\throws \tcode{bad_alloc} or \tcode{system_error} when an exception is
required\iref{thread.req.exception}.

\pnum
\errors
\begin{itemize}
\item \tcode{resource_unavailable_try_again} --- if some non-memory resource
limitation prevents initialization.

\item \tcode{operation_not_permitted} --- if the thread does not have the
privilege to perform the operation.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{condition_variable_any}!destructor}%
\begin{itemdecl}
~condition_variable_any();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires There shall be no thread blocked on \tcode{*this}. \begin{note} That is, all
threads shall have been notified; they may subsequently block on the lock specified in the
wait.
This relaxes the usual rules, which would have required all wait calls to happen before
destruction. Only the notification to unblock the wait needs to happen before destruction.
The user should take care to ensure that no threads wait on \tcode{*this} once the destructor has
been started, especially when the waiting threads are calling the wait functions in a loop or
using the overloads of \tcode{wait}, \tcode{wait_for}, or \tcode{wait_until} that take a predicate.
\end{note}

\pnum\effects Destroys the object.
\end{itemdescr}

\indexlibrarymember{notify_one}{condition_variable_any}%
\begin{itemdecl}
void notify_one() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects If any threads are blocked waiting for \tcode{*this}, unblocks one of those threads.
\end{itemdescr}

\indexlibrarymember{notify_all}{condition_variable_any}%
\begin{itemdecl}
void notify_all() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects Unblocks all threads that are blocked waiting for \tcode{*this}.
\end{itemdescr}


%**************************************
%*** wait functions:

{\color{insertcolor}
\rSec3[thread.condvarany.wait]{Noninterruptable waits}
}

% wait(Lock)
\indexlibrarymember{wait}{condition_variable_any}%
\begin{itemdecl}
template<class Lock>
  void wait(Lock& lock);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{itemize}
\item Atomically calls \tcode{lock.unlock()} and blocks on \tcode{*this}.
\item When unblocked, calls \tcode{lock.lock()} (possibly blocking on the lock) and returns.
\item The function will unblock when requested by a call to \tcode{notify_one()},
a call to \tcode{notify_all()}, or spuriously.
\end{itemize}

\pnum
\remarks
If the function fails to meet the postcondition, \tcode{terminate()}
shall be called\iref{except.terminate}.
\begin{note} This can happen if the re-locking of the mutex throws an exception. \end{note}

\pnum\postconditions \tcode{lock} is locked by the calling thread.

\pnum\throws Nothing.

\end{itemdescr}


% wait(Lock, Predicate)
\indexlibrarymember{wait}{condition_variable_any}%
\begin{itemdecl}
template<class Lock, class Predicate>
  void wait(Lock& lock, Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
while (!pred())
  wait(lock);
\end{codeblock}
\end{itemdescr}


% wait_until(Lock, Timepoint)
\indexlibrarymember{wait_until}{condition_variable_any}%
\begin{itemdecl}
template<class Lock, class Clock, class Duration>
  cv_status wait_until(Lock& lock, const chrono::time_point<Clock, Duration>& abs_time);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects

\begin{itemize}
\item
Atomically calls \tcode{lock.unlock()} and blocks on \tcode{*this}.

\item
When unblocked, calls \tcode{lock.lock()} (possibly blocking on the lock) and returns.

\item
The function will unblock when requested by a call to \tcode{notify_one()}, a call to \tcode{notify_all()},
expiration of the absolute timeout\iref{thread.req.timing} specified by \tcode{abs_time},
or spuriously.

\item
If the function exits via an exception, \tcode{lock.lock()} shall be called prior to exiting the function.
\end{itemize}

\pnum
\remarks
If the function fails to meet the postcondition, \tcode{terminate()}
shall be called\iref{except.terminate}.
\begin{note} This can happen if the re-locking of the mutex throws an exception. \end{note}

\pnum
\postconditions \tcode{lock} is locked by the calling thread.

\pnum
\returns \tcode{cv_status::timeout} if
the absolute timeout\iref{thread.req.timing} specified by \tcode{abs_time} expired,
otherwise \tcode{cv_status::no_timeout}.

\pnum
\throws Timeout-related
exceptions\iref{thread.req.timing}.

\end{itemdescr}

\indexlibrarymember{wait_for}{condition_variable_any}%
\begin{itemdecl}
template<class Lock, class Rep, class Period>
  cv_status wait_for(Lock& lock, const chrono::duration<Rep, Period>& rel_time);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return wait_until(lock, chrono::steady_clock::now() + rel_time);
\end{codeblock}

\pnum
\returns \tcode{cv_status::timeout} if
the relative timeout\iref{thread.req.timing} specified by \tcode{rel_time} expired,
otherwise \tcode{cv_status::no_timeout}.

\pnum
\remarks
If the function fails to meet the postcondition, \tcode{terminate()}
shall be called\iref{except.terminate}.
\begin{note} This can happen if the re-locking of the mutex throws an exception. \end{note}

\pnum
\postconditions \tcode{lock} is locked by the calling thread.

\pnum
\throws Timeout-related
exceptions\iref{thread.req.timing}.

\end{itemdescr}

\indexlibrarymember{wait_until}{condition_variable_any}%
\begin{itemdecl}
template<class Lock, class Clock, class Duration, class Predicate>
  bool wait_until(Lock& lock, const chrono::time_point<Clock, Duration>& abs_time, Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
while (!pred())
  if (wait_until(lock, abs_time) == cv_status::timeout)
    return pred();
return true;
\end{codeblock}

\pnum
\begin{note} There is no blocking if \tcode{pred()} is initially \tcode{true}, or
if the timeout has already expired. \end{note}

\pnum
\begin{note} The returned value indicates whether the predicate evaluates to \tcode{true}
regardless of whether the timeout was triggered. \end{note}
\end{itemdescr}

\indexlibrarymember{wait_for}{condition_variable_any}%
\begin{itemdecl}
template<class Lock, class Rep, class Period, class Predicate>
  bool wait_for(Lock& lock, const chrono::duration<Rep, Period>& rel_time, Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));
\end{codeblock}
\end{itemdescr}



\clearpage

%**********************************************************
%\begin{codeblock}
%******************
%* NEW:
%******************
%\end{codeblock}
{\color{insertcolor}

%    template <class Lock, class Predicate>
%      bool wait_until(Lock& lock,
%                      Predicate pred,
%                      stop_token stoken);
%    template <class Lock, class Clock, class Duration, class Predicate>
%      bool wait_until(Lock& lock,
%                      const chrono::time_point<Clock, Duration>& abs_time
%                      Predicate pred,
%                      stop_token stoken);
%    template <class Lock, class Rep, class Period, class Predicate>
%      bool wait_for(Lock& lock,
%                    const chrono::duration<Rep, Period>& rel_time,
%                    Predicate pred,
%                    stop_token stoken);

%**************************************
\rSec3[thread.condvarany.interruptwait]{Interruptable waits}

\pnum
The following wait functions will stop waiting
as soon as there is a request to stop for the passed \tcode{stop_token}.
In that case the functions return immediately,
returning \tcode{false} if the predicate evaluates to \tcode{false}. 

% Hans Boehm:
%We then also need some statement for the waiting functions that if they return with an stopped/interrupted status,
% their synchronization behavior is as though they called stop_requested().
%{\color{blue}
%[{\itshape{}Editorial note:} Because all signatures here in the effects clause call
%        \tcode{stop_requested()}, we don't need wording
%        that the calls synchronize with \tcode{interrupt()/request_stop()}. ]
%}


%**** untimed wait_until (with pred)
% return false if stoken.stop_requested():

\begin{itemdecl}
template <class Lock, class Predicate>
  bool wait_until(Lock& lock,
                  Predicate pred,
                  stop_token stoken);
\end{itemdecl}
%{\color{blue}
%[{\itshape{}Editorial note:} {\color{diffcolor}This color signals differences to the corresponding \tcode{wait()} function without the stop token parameter.} ]
%}

\begin{itemdescr}

%{\color{diffcolor}
 \pnum\effects Registers \tcode{*this} to get notified on a request to stop on \tcode{stoken}
               during this call and then equivalent to:
\begin{codeblock}
while (!stoken.stop_requested()) {
  if (pred())
    return true;
  wait(lock);
}
return pred();
\end{codeblock}

 \pnum \begin{note} The returned value indicates whether the predicate evaluated to
        \tcode{true} regardless of whether there was a request to stop. \end{note}

 \pnum \postconditions \tcode{lock} is locked by the calling thread.

 \pnum \remarks
        If the function fails to meet the postcondition, \tcode{terminate()}
        shall be called\iref{except.terminate}.
        \begin{note} This can happen if the re-locking of the mutex throws an exception. \end{note}

 \pnum \throws 
        Any exception thrown by \tcode{pred}.

%}%diffcolor

\end{itemdescr}



%**** wait_until (with pred)
% return false if stoken.stop_requested():

\begin{itemdecl}
template <class Lock, class Clock, class Duration, class Predicate>
  bool wait_until(Lock& lock,
                  const chrono::time_point<Clock, Duration>& abs_time
                  Predicate pred,
                  stop_token stoken);
\end{itemdecl}
%{\color{blue}
%[{\itshape{}Editorial note:} {\color{diffcolor}This color signals differences to the corresponding \tcode{wait_until()} function without the stop token parameter.} ]
%}

\begin{itemdescr}
 \pnum\effects Registers \tcode{*this} to get notified on a request to stop on \tcode{stoken}
                during this call and then equivalent to:
\begin{codeblock}
while (!stoken.stop_requested()) {
  if (pred())
    return true;
  if (cv.wait_until(lock, abs_time) == cv_status::timeout)
    return pred();
}
return pred();
\end{codeblock}

\pnum
\begin{note} There is no blocking if
             \tcode{pred()} is initially \tcode{true}, 
             \tcode{stoken.stop_requested()} was already \tcode{true} or
             the timeout has already expired. \end{note}

\pnum
\begin{note} The returned value indicates whether the predicate evaluates to \tcode{true}
regardless of whether the timeout was triggered or a request to stop was made. \end{note}

 \pnum \postconditions \tcode{lock} is locked by the calling thread.

 \pnum \remarks
        If the function fails to meet the postcondition, \tcode{terminate()}
        shall be called\iref{except.terminate}.
        \begin{note} This can happen if the re-locking of the mutex throws an exception. \end{note}

 \pnum \throws 
        Timeout-related exceptions \iref{thread.req.timing},
        or any exception thrown by \tcode{pred}.

%{\color{diffcolor}
% \pnum\sync If the function returns with an stopped/interrupted status, 
%                their synchronization behavior is as though it called \tcode{stop_requested()}.
%}%diffcolor
\end{itemdescr}


%**** wait_for (with pred)
% return false if stoken.stop_requested():

\begin{itemdecl}
template <class Lock, class Rep, class Period, class Predicate>
  bool wait_for(Lock& lock,
                const chrono::duration<Rep, Period>& rel_time,
                Predicate pred,
                stop_token stoken);
\end{itemdecl}
%{\color{blue}
%[{\itshape{}Editorial note:} {\color{diffcolor}This color signals differences to the corresponding \tcode{wait_for()} function without the stop token parameter.} ]
%}
\begin{itemdescr}
 \pnum \effects Equivalent to:
\begin{codeblock}
return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred), std::move(stoken));
\end{codeblock}
\end{itemdescr}

}%\color{insertcolor}


\vspace{5ex}

%******************************************************************
\rSec1[futures]{Futures}

...

