%!TEX root = std.tex
\setcounter{chapter}{29}
\rSec0[thread]{Thread support library}

%******************************************************************
\rSec1[jthread.general]{General}

\pnum
The following subclauses describe components to create and manage
threads\iref{intro.multithread}, perform mutual exclusion, and communicate conditions
and values
between threads, as summarized in \tref{thread.lib.summary}.

\begin{libsumtab}{Thread support library summary}{tab:thread.lib.summary}
\ref{thread.req}      & Requirements          &                               \\ \rowsep
\ref{thread.threads}  & Threads               & \tcode{<thread>}              \\ \rowsep
\color{insertcolor}
\ref{thread.interrupt_token} &
        \color{insertcolor} Interrupt Tokens       &
                \color{insertcolor} \tcode{<interrupt_token>}              \\ \rowsep
\color{insertcolor}
\ref{thread.jthreads} &
        \color{insertcolor} Joining Threads       &
                \color{insertcolor} \tcode{<jthread>}              \\ \rowsep
\ref{thread.mutex}    & Mutual exclusion      & \tcode{<mutex>}               \\
                      &                       & \tcode{<shared_mutex>}        \\ \rowsep
\ref{thread.condition}& Condition variables   & \tcode{<condition_variable>}  \\ \rowsep
\ref{futures}         & Futures               & \tcode{<future>}              \\
\end{libsumtab}

%******************************************************************
\rSec1[thread.req]{Requirements}

...

%******************************************************************
\rSec1[thread.threads]{Threads}

...

\clearpage

{\color{insertcolor}

%******************************************************************
\rSec1[thread.interrupt_token]{Interrupt Tokens}

\pnum
\ref{thread.interrupt_token} describes components that can be used to
asynchonously signal an interrupt.
The interrupt can only be signaled exactly once
by one of multiple \tcode{interrupt_source}s to one or multiple \tcode{interrupt_token}s.
Callbacks can be registered as \tcode{interrupt_token}s to be called when the interrupt is signaled.

For this, classes \tcode{interrupt_source} and \tcode{interrupt_token} implement semantics of shared ownership of an
associated atomic interrupt state (an atomic token to signal an interrupt).
The last remaining owner of the interrupt state automatically 
releases the resources associated with the interrupt state.

\pnum
Calls to \tcode{interrupt()}, \tcode{interrupted()},
\tcode{valid()}, and \tcode{interruptible()}
are atomic operations (6.8.2.1p3 \ref{intro.races})
on the interrupt state contained in the interrupt state object.
Hence concurrent calls to these functions do not introduce data races. 
A call to \tcode{interrupt()} synchronizes with any call to \tcode{interrupt()} and
\tcode{interrupted()} that observes the interrupt.
%(and hence returns \tcode{true} or throws).

%**************************
\rSec2[thread.interrupt_token.syn]{Header \tcode{<interrupt_token>} synopsis}
\indexhdr{interrupt_token}%

\begin{codeblock}
namespace std {
  // \ref{interrupt_token} class \tcode{interrupt_token}
  template <typename Callback> class interrupt_callback;
  class interrupt_source;
  class interrupt_token;
}
\end{codeblock}


%**************************
% interrupt_callback
%**************************
\indexlibrary{\idxcode{interrupt_callback}}%
\rSec2[interrupt_callback]{Class \tcode{interrupt_callback}}

\pnum
\indexlibrary{\idxcode{interrupt_callback}}%

\begin{codeblock}
namespace std {
  template <typename Callback>
  class interrupt_callback {
  public:
    // \ref{interrupt_callback.constr} create, copy, destroy:
    interrupt_callback(interrupt_token it, Callback&& cb);
    ~interrupt_callback();

    interrupt_callback(const interrupt_callback&) = delete;
    interrupt_callback(interrupt_callback&&) = delete;
    interrupt_callback& operator=(const interrupt_callback&) = delete;
    interrupt_callback& operator=(interrupt_callback&&) = delete;
  }
}
\end{codeblock}

%*****
\rSec3[interrupt_callback.constr]{\tcode{interrupt_callback} constructors}

\indexlibrary{\idxcode{interrupt_callback}!constructor}%
\begin{itemdecl}
interrupt_callback(interrupt_token it, Callback&& cb) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\requires \tcode{cb} is a callable object taking no parameters.

  \pnum\effects Constructs a new \tcode{interrupt_callback} object that can be used to be called when an interrupt
                is signaled at \tcode{it}.
                If \tcode{it.interrupted()} \tcode{cb} is immediatelly called.
\end{itemdescr}

%**************************
% interrupt_source
%**************************
\indexlibrary{\idxcode{interrupt_source}}%
\rSec2[interrupt_source]{Class \tcode{interrupt_source}}

\pnum
\indexlibrary{\idxcode{interrupt_token}}%
The class \tcode{interrupt_source} implements semantics of signaling interrupts
to \tcode{interrupt_token}s (\ref{interrupt_token}).
All owners can signal an interrupt, provided the token is valid.
An interrupt can only be signaled once.
All owners can check whether an interrupt was signaled.

\begin{codeblock}
namespace std {
  class interrupt_source {
  public:
    // \ref{interrupt_source.constr} create, copy, destroy:
    explicit interrupt_source() noexcept;
    explicit interrupt_source(nullptr_t);

    interrupt_source(const interrupt_source&) noexcept;
    interrupt_source(interrupt_source&&) noexcept;
    interrupt_source& operator=(const interrupt_source&) noexcept;
    interrupt_source& operator=(interrupt_source&&) noexcept;
    ~interrupt_source();
    void swap(interrupt_source&) noexcept;

    // \ref{interrupt_source.mem} interrupt handling:
    interrupt_token get_token() const noexcept;
    bool valid() const noexcept;
    bool interrupted() const noexcept;
    bool interrupt();

    friend bool operator== (const interrupt_source& lhs, const interrupt_source& rhs);
    friend bool operator!= (const interrupt_source& lhs, const interrupt_source& rhs);
  };
}
\end{codeblock}


{\color{diffcolor}
\begin{note} Implementations are expected to implement interruption in terms of a
             type-erased facility that allows any destructible and invocable object
             to be called by \tcode{interruption_source::interrupt()} in a future version of C++.
             \end{note}
}

%***** constructors
\rSec3[interrupt_source.constr]{\tcode{interrupt_source} constructors}

\indexlibrary{\idxcode{interrupt_source}!constructor}%
\begin{itemdecl}
interrupt_source() noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Constructs a new \tcode{interrupt_source} object that can signal interrupts.

  \pnum\postconditions \tcode{valid() == true} and \tcode{interrupted() == false}.
\end{itemdescr}

\indexlibrary{\idxcode{interrupt_source}!constructor}%
\begin{itemdecl}
interrupt_source(nullptr_t) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Constructs a new \tcode{interrupt_source} object that can't be used to signal interrupts.
                \begin{note} Therefore, no resources have to be associated for the state.  \end{note}

  \pnum\postconditions \tcode{valid() == false}.
\end{itemdescr}

%*** special members:

\indexlibrary{\idxcode{interrupt_source}!constructor}%
\begin{itemdecl}
interrupt_source(const interrupt_source& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects If \tcode{rhs} is not valid, constructs an \tcode{interrupt_source} object
                that is not valid;
                otherwise, constructs an \tcode{interrupt_source}
                that shares the ownership of the interrupt state with \tcode{rhs}.

  \pnum\postconditions \tcode{valid() == rhs.valid()}
                and \tcode{interrupted() == rhs.interrupted()}
                and \tcode{*this == rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{interrupt_source}!constructor}%
\begin{itemdecl}
interrupt_source(interrupt_source&& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Move constructs an object of type \tcode{interrupt_source} from \tcode{rhs}.

  \pnum\postconditions \tcode{*this} shall contain the old value of \tcode{rhs} and
                        \tcode{rhs.valid() == false}.
\end{itemdescr}

%*****
\rSec3[interrupt_source.destr]{\tcode{interrupt_source} destructor}

\indexlibrary{\idxcode{interrupt_source}!destructor}%
\begin{itemdecl}
~interrupt_source();
\end{itemdecl}

\begin{itemdescr}
 \pnum\effects If \tcode{valid()} and \tcode{*this} is the last owner of the interrupt state,
                releases the resources associated with the interrupt state.
\end{itemdescr}

%*****
\rSec3[interrupt_source.assign]{\tcode{interrupt_source} assignment}

\indexlibrarymember{operator=}{interrupt_source}%
\begin{itemdecl}
interrupt_source& operator=(const interrupt_source& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Equivalent to: \tcode{interrupt_source(rhs).swap(*this);}

  \pnum\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{interrupt_source}%
\begin{itemdecl}
interrupt_source& operator=(interrupt_source&& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Equivalent to: \tcode{interrupt_source(std::move(rhs)).swap(*this);}

  \pnum\returns \tcode{*this}.
\end{itemdescr}

%*****
\rSec3[interrupt_source.swap]{\tcode{interrupt_source} swap}

\indexlibrarymember{swap}{interrupt_source}%
\begin{itemdecl}
void swap(interrupt_source& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
 \pnum \effects Swaps the state of \tcode{*this} and \tcode{rhs}.
\end{itemdescr}


%***** get_token()
\rSec3[interrupt_source.mem]{\tcode{interrupt_source} members}

\indexlibrarymember{get_token}{interrupt_source}%
\begin{itemdecl}
interrupt_token get_token() const noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects If \tcode{!valid()}, constructs an \tcode{interrupt_token} object
                that is not valid;
                otherwise, constructs an \tcode{interrupt_token} object \tcode{it}
                that shares the ownership of the interrupt state with \tcode{*this}.

  \pnum\postconditions \tcode{valid() == it.valid()}
                and \tcode{interrupted() == it.interrupted()}.
\end{itemdescr}


\indexlibrarymember{valid}{interrupt_source}%
\begin{itemdecl}
bool valid() const noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \tcode{true} if the interrupt source can be used to signal interrupts.
                \begin{note} Returns \tcode{false} if the object was created with the \tcode{nullptr}
                             fro the values was moved away.
                             \end{note}
\end{itemdescr}

\indexlibrarymember{interrupted}{interrupt_source}%
\begin{itemdecl}
bool interrupted() const noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \tcode{true} if \tcode{valid()} 
                and \tcode{interrupt()} was called by one of the owners.
\end{itemdescr}

\indexlibrarymember{interrupt}{interrupt_source}%
\begin{itemdecl}
bool interrupt();
\end{itemdecl}
\begin{itemdescr}
  %\pnum\requires \tcode{valid() == true}
  %Hans:
  %Did we discuss whether interrupt() on an invalid (e.g. default constructed) interrupt token should be a no-op,
  %rather than undefined? I would expect that to be convenient if we start passing interrupt_tokens around explicitly.
  %Presumably a lot of short-lived tasks don't care about interruption, but might be used in a context in which an
  %interrupt token is expected. With the change, you could just pass a default-constructed one.

  \pnum\effects If \tcode{!valid()} or \tcode{interrupted()} the call has no effect. 
                Otherwise, signals an interrupt so that \tcode{interrupted() == true}
                and all registered callbacks are synchronously called.
                \begin{note} Signaling an interrupt includes notifying all condition variables
                             of type \tcode{condition_variable_any}
                             temporarily registered during an interruptable wait (\ref{thread.condition.interrupt_source})
                             \end{note}

  \pnum\postconditions \tcode{!valid() || interrupted()}

  \pnum\returns The value of \tcode{interrupted()} prior to the call.
\end{itemdescr}


%*****
\rSec3[interrupt_source.cmp]{\tcode{interrupt_source} comparisons}

\indexlibrarymember{operator==}{interrupt_source}%
\begin{itemdecl}
bool operator== (const interrupt_source& lhs, const interrupt_source& rhs);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \tcode{!lhs.valid() \&\& !rhs.valid()} or
                whether \tcode{lhs} and \tcode{rhs} refer to the
                same interrupt state
                (copied or moved from the same initial \tcode{interrupt_source} object).
\end{itemdescr}

\indexlibrarymember{operator!=}{interrupt_source}%
\begin{itemdecl}
bool operator!= (const interrupt_source& lhs, const interrupt_source& rhs);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \tcode{!(lhs==rhs)}.
\end{itemdescr}


%**************************
% interrupt_token
%**************************
\indexlibrary{\idxcode{interrupt_token}}%
\rSec2[interrupt_token]{Class \tcode{interrupt_token}}

\pnum
\indexlibrary{\idxcode{interrupt_token}}%
The class \tcode{interrupt_token} implements semantics getting interrupts signaled from
the \tcode{interrupt_source} object they were created from.
All tokens can check whether an interrupt was signaled.
When an interrupt is signaled, which is possible only once,
any registered \tcode{interrupt_callback} (\ref{interrupt_callback}) is called.
Registering a callback after an interrupt was already signaled calls the callback immediately.

\begin{codeblock}
namespace std {
  class interrupt_token {
  public:
    // \ref{interrupt_token.constr} create, copy, destroy:
    explicit interrupt_token() noexcept;

    interrupt_token(const interrupt_token&) noexcept;
    interrupt_token(interrupt_token&&) noexcept;
    interrupt_token& operator=(const interrupt_token&) noexcept;
    interrupt_token& operator=(interrupt_token&&) noexcept;
    ~interrupt_token();
    void swap(interrupt_token&) noexcept;

    // \ref{interrupt_token.mem} interrupt handling:
    bool interrupted() const noexcept;
    bool interruptible() const noexcept;

    friend bool operator== (const interrupt_token& lhs, const interrupt_token& rhs);
    friend bool operator!= (const interrupt_token& lhs, const interrupt_token& rhs);
  };
}
\end{codeblock}


%*****
\rSec3[interrupt_token.constr]{\tcode{interrupt_token} constructors}

\indexlibrary{\idxcode{interrupt_token}!constructor}%
\begin{itemdecl}
interrupt_token() noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Constructs a new \tcode{interrupt_token} object that can't be used to signal interrupts.
                \begin{note} Therefore, no resources have to be associated for the state.  \end{note}

  \pnum\postconditions \tcode{interruptible() == false}.
\end{itemdescr}

%***** special members:

\indexlibrary{\idxcode{interrupt_token}!constructor}%
\begin{itemdecl}
interrupt_token(const interrupt_token& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects If \tcode{rhs} is not valid, constructs an \tcode{interrupt_token} object
                that is not valid;
                otherwise, constructs an \tcode{interrupt_token}
                that shares the ownership of the interrupt state with \tcode{rhs}.

  \pnum\postconditions \tcode{valid() == rhs.valid()}
                and \tcode{interrupted() == rhs.interrupted()}
                and \tcode{*this == rhs}.
\end{itemdescr}

\indexlibrary{\idxcode{interrupt_token}!constructor}%
\begin{itemdecl}
interrupt_token(interrupt_token&& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Move constructs an object of type \tcode{interrupt_token} from \tcode{rhs}.

  \pnum\postconditions \tcode{*this} shall contain the old value of \tcode{rhs} and
                        \tcode{rhs.valid() == false}.
\end{itemdescr}

%*****
\rSec3[interrupt_token.destr]{\tcode{interrupt_token} destructor}

\indexlibrary{\idxcode{interrupt_token}!destructor}%
\begin{itemdecl}
~interrupt_token();
\end{itemdecl}

\begin{itemdescr}
 \pnum\effects If \tcode{valid()} and \tcode{*this} is the last owner of the interrupt state,
                releases the resources associated with the interrupt state.
\end{itemdescr}

%*****
\rSec3[interrupt_token.assign]{\tcode{interrupt_token} assignment}

\indexlibrarymember{operator=}{interrupt_token}%
\begin{itemdecl}
interrupt_token& operator=(const interrupt_token& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Equivalent to: \tcode{interrupt_token(rhs).swap(*this);}

  \pnum\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{interrupt_token}%
\begin{itemdecl}
interrupt_token& operator=(interrupt_token&& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Equivalent to: \tcode{interrupt_token(std::move(rhs)).swap(*this);}

  \pnum\returns \tcode{*this}.
\end{itemdescr}

%*****
\rSec3[interrupt_token.swap]{\tcode{interrupt_token} swap}

\indexlibrarymember{swap}{interrupt_token}%
\begin{itemdecl}
void swap(interrupt_token& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Swaps the state of \tcode{*this} and \tcode{rhs}.
\end{itemdescr}


%*****
\rSec3[interrupt_token.mem]{\tcode{interrupt_token} members}

\indexlibrarymember{interrupted}{interrupt_token}%
\begin{itemdecl}
bool interrupted() const noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \tcode{true} if \tcode{true}
                or initialized with \tcode{false} and \tcode{interrupt()} was called
                by one of the owners.
  \pnum\returns \tcode{true} if \tcode{valid()} 
                and \tcode{interrupt()} was called by one of the owners.
\end{itemdescr}

\indexlibrarymember{interruptible}{interrupt_token}%
\begin{itemdecl}
bool interruptible() const noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \tcode{true} if the interrupt token did or still can receive an interrupt signal
                so that registered callbacks can be called (immediately or later).
                \begin{note} Returns \tcode{false} if registering a callback
                                doesn't make any sense because it can't be called (anymore).
                                (e.g., because it is not interrupted yet
                                 and there is no more associated \tcode{interrupt_source}
                                 (\ref{interrupt_source})).
                             \end{note}
\end{itemdescr}


%*****
\rSec3[interrupt_token.cmp]{\tcode{interrupt_token} comparisons}

\indexlibrarymember{operator==}{interrupt_token}%
\begin{itemdecl}
bool operator== (const interrupt_token& lhs, const interrupt_token& rhs);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \tcode{!lhs.valid() \&\& !rhs.valid()} or
                whether \tcode{lhs} and \tcode{rhs} refer to the
                same interrupt state
                (copied or moved from the same initial \tcode{interrupt_token} object).
\end{itemdescr}

\indexlibrarymember{operator!=}{interrupt_token}%
\begin{itemdecl}
bool operator!= (const interrupt_token& lhs, const interrupt_token& rhs);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \tcode{!(lhs==rhs)}.
\end{itemdescr}


\clearpage

%******************************************************************
\rSec1[thread.jthreads]{Joining Threads}


\pnum
\ref{thread.jthreads} describes components that can be used to create and manage threads
with the ability to signal interrupts to cooperatively cancel the running thread.

%**************************
\rSec2[thread.jthread.syn]{Header \tcode{<jthread>} synopsis}
\indexhdr{jthread}%

\begin{codeblock}
#include <interrupt_token>

namespace std {
  // \ref{thread.jthread.class} class \tcode{jthread}
  class jthread;

  void swap(jthread& x, jthread& y) noexcept;
}
\end{codeblock}


%**************************
\rSec2[thread.jthread.class]{Class \tcode{jthread}}

\pnum
The class \tcode{jthread} provides a mechanism
to create a new thread of execution.
The functionality is the same as for class \tcode{thread} (\ref{thread.thread.class})
with the additional ability to signal an interrupt and to
automatically \tcode{join()} the started thread.

{\color{blue}
[{\itshape{}Editorial note:} {\color{diffcolor}This color signals differences to class \tcode{std::thread}.} ]
}

\indexlibrary{\idxcode{jthread}}%
\begin{codeblock}
namespace std {
  class jthread {
  public:
    // types
    using id = thread::id;
    using native_handle_type = thread::native_handle_type;

    // construct/copy/destroy
    jthread() noexcept;
    template<class F, class... Args> explicit jthread(F&& f, Args&&... args);
    ~jthread();
    jthread(const jthread&) = delete;
    jthread(jthread&&) noexcept;
    jthread& operator=(const jthread&) = delete;
    jthread& operator=(jthread&&) noexcept;

    // members
    void swap(jthread&) noexcept;
    bool joinable() const noexcept;
    void join();
    void detach();
    id get_id() const noexcept;
    native_handle_type native_handle();     // see~\ref{thread.req.native}
\end{codeblock}
{\color{diffcolor}
\begin{codeblock}
    // interrupt token handling
    interrupt_token get_interrupt_source() const noexcept;
    bool interrupt() noexcept;
\end{codeblock}
}%\color{diffcolor}
\begin{codeblock}
    // static members
    static unsigned int hardware_concurrency() noexcept;
  
\end{codeblock}
{\color{diffcolor}
\begin{codeblock}
  private:
    interrupt_token isource;                 // \expos
  };
\end{codeblock}
}%\color{diffcolor}
\begin{codeblock}
}
\end{codeblock}


\rSec3[thread.jthread.constr]{\tcode{jthread} constructors}

\indexlibrary{\idxcode{jthread}!constructor}%
\begin{itemdecl}
jthread() noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Constructs a \tcode{jthread} object that does not represent a thread of execution.

  \pnum\postconditions \tcode{get_id() == id()}
        {\color{diffcolor} and \tcode{isource.valid() == false}}.
\end{itemdescr}

\indexlibrary{\idxcode{jthread}!constructor}%
\begin{itemdecl}
template<class F, class... Args> explicit jthread(F&& f, Args&&... args);
\end{itemdecl}
\begin{itemdescr}
  \pnum
\requires\ \tcode{F} and each $\tcode{T}_i$ in \tcode{Args} shall satisfy the
\oldconcept{MoveConstructible} requirements.
{\color{diffcolor}
        \tcode{%
                \placeholdernc{INVOKE}(\brk{}%
                \placeholdernc{DECAY_COPY}(\brk{}%
                std::forward<F>(f)),
                isource,
                \placeholdernc{DECAY_COPY}(\brk{}%
                std::forward<Args>(\brk{}args))...)}
        or
}
        \tcode{%
                \placeholdernc{INVOKE}(\brk{}%
                \placeholdernc{DECAY_COPY}(\brk{}%
                std::forward<F>(f)),
                \placeholdernc{DECAY_COPY}(\brk{}%
                std::forward<Args>(\brk{}args))...)}
\iref{func.require} shall be a valid expression.

\pnum\remarks
This constructor shall not participate in overload resolution if \tcode{remove_cvref_t<F>}
is the same type as \tcode{std::jthread}.

\pnum\effects
{\color{diffcolor} Initializes \tcode{isource} and
}
constructs an object of type \tcode{jthread}.
The new thread of execution executes
{\color{diffcolor}
        \tcode{%
                \placeholdernc{INVOKE}(\brk{}%
                \placeholdernc{DECAY_COPY}(\brk{}%
                std::forward<F>(f)),
                isource,%
                \placeholdernc{DECAY_COPY}(\brk{}%
                std::forward<Args>(\brk{}args))...)}
if that expression is well-formed,
otherwise
}
        \tcode{%
                \placeholdernc{INVOKE}(\brk{}%
                \placeholdernc{DECAY_COPY}(\brk{}%
                std::forward<F>(f)),
                \placeholdernc{DECAY_COPY}(\brk{}%
                std::forward<Args>(\brk{}args))...)}
with the calls to
\tcode{\placeholder{DECAY_COPY}} being evaluated in the constructing thread.
Any return value from this invocation is ignored.
\begin{note} This implies that any exceptions not thrown from the invocation of the copy
of \tcode{f} will be thrown in the constructing thread, not the new thread. \end{note}
If the invocation
with \tcode{\placeholdernc{INVOKE}()}
%of
%\tcode{%
%\placeholdernc{INVOKE}(\brk{}%
%\placeholdernc{DECAY_COPY}(\brk{}%
%std::forward<F>(f)),
%\placeholdernc{DECAY_COPY}(\brk{}%
%std::forward<Args>(args))...)}
terminates with an uncaught exception, \tcode{terminate()} shall be called.

\pnum\sync The completion of the invocation of the constructor
synchronizes with the beginning of the invocation of the copy of \tcode{f}.

\pnum\postconditions \tcode{get_id() != id()}.
{\color{diffcolor}
                     \tcode{isource.valid() == true}.
}
                     \tcode{*this} represents the newly started thread.
{\color{diffcolor}
\begin{note} Note that the calling thread can signal an interrupt only once,
                because it can't replace this interrupt token.  \end{note}
}%\color{diffcolor}

\pnum\throws \tcode{system_error} if unable to start the new thread.

\pnum\errors
\begin{itemize}
\item \tcode{resource_unavailable_try_again} --- the system lacked the necessary
resources to create another thread, or the system-imposed limit on the number of
threads in a process would be exceeded.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{jthread}!constructor}%
\begin{itemdecl}
jthread(jthread&& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an object of type \tcode{jthread} from \tcode{x}, and sets
\tcode{x} to a default constructed state.

\pnum
\postconditions \tcode{x.get_id() == id()} and \tcode{get_id()} returns the
value of \tcode{x.get_id()} prior to the start of construction.
{\color{diffcolor}
\tcode{isource} yields the value of \tcode{x.isource} prior to the start of construction
and \tcode{x.isource.valid() == false}.
}%\color{diffcolor}

\end{itemdescr}

\rSec3[thread.jthread.destr]{\tcode{jthread} destructor}

\indexlibrary{\idxcode{jthread}!destructor}%
\begin{itemdecl}
~jthread();
\end{itemdecl}

{\color{diffcolor}
\begin{itemdescr}
\pnum
If \tcode{joinable()}, calls \tcode{interrupt()} and \tcode{join()}.
Otherwise, has no effects.
\begin{note} Operations on \tcode{*this} are not synchronized. \end{note}
\end{itemdescr}
}%\color{diffcolor}

\rSec3[thread.jthread.assign]{\tcode{jthread} assignment}

\indexlibrarymember{operator=}{jthread}%
\begin{itemdecl}
jthread& operator=(jthread&& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{joinable()}, calls \tcode{interrupt()} and \tcode{join()}.
Assigns the
state of \tcode{x} to \tcode{*this} and sets \tcode{x} to a default constructed state.

{\color{diffcolor}
\pnum
\postconditions \tcode{x.get_id() == id()} and \tcode{get_id()} returns the value of
\tcode{x.get_id()} prior to the assignment.
\tcode{isource} yields the value of \tcode{x.isource} prior to the assignment
and \tcode{x.isource.valid() == false}.
}%\color{diffcolor}

\pnum
\returns \tcode{*this}.
\end{itemdescr}


\rSec3[thread.jthread.interrupt]{\tcode{jthread} interrupt members}

{\color{diffcolor}
\indexlibrarymember{get_interrupt_source}{jthread}%
\begin{itemdecl}
interrupt_token get_interrupt_source() const noexcept
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Equivalent to: \tcode{return isource;}
\end{itemdescr}

\indexlibrarymember{interrupt}{jthread}%
\begin{itemdecl}
bool interrupt() noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Equivalent to: \tcode{return isource.interrupt();}
\end{itemdescr}
}%\color{diffcolor}

%\rSec3[thread.jthread.static]{\tcode{jthread} static members}
%
%\indexlibrarymember{hardware_concurrency}{thread}%
%\begin{itemdecl}
%unsigned hardware_concurrency() noexcept;
%\end{itemdecl}
%\begin{itemdescr}
%  \pnum\effects Equivalent to: \tcode{return thread::hardware_concurrency()}.
%\end{itemdescr}
%
%\rSec3[thread.jthread.algorithm]{\tcode{jthread} specialized algorithms}
%
%\indexlibrarymember{swap}{jthread}%
%\begin{itemdecl}
%void swap(jthread& x, jthread& y) noexcept;
%\end{itemdecl}
%\begin{itemdescr}
%  \pnum\effects As if by \tcode{x.swap(y)}.
%\end{itemdescr}

}%\color{insertcolor}


\clearpage

%******************************************************************
\rSec1[thread.mutex]{Mutual exclusion}

...

%******************************************************************
\rSec1[thread.condition]{Condition variables}

...

\rSec2[condition_variable.syn]{Header \tcode{<condition_variable>} synopsis}

...

\rSec2[thread.condition.nonmember]{Non-member functions}

...

\rSec2[thread.condition.condvar]{Class \tcode{condition_variable}}

...

\rSec2[thread.condition.condvarany]{Class \tcode{condition_variable_any}}

...

\indexlibrary{\idxcode{condition_variable_any}}%
\begin{codeblock}
namespace std {
  class condition_variable_any {
  public:
    condition_variable_any();
    ~condition_variable_any();

    condition_variable_any(const condition_variable_any&) = delete;
    condition_variable_any& operator=(const condition_variable_any&) = delete;

    void notify_one() noexcept;
    void notify_all() noexcept;

\end{codeblock}
{\color{insertcolor}
\begin{codeblock}
    // \ref{thread.condvarany.wait} noninterruptable waits:
\end{codeblock}
}%insertcolor
\begin{codeblock}
    template<class Lock>
      void wait(Lock& lock);
    template<class Lock, class Predicate>
      void wait(Lock& lock, Predicate pred);

    template<class Lock, class Clock, class Duration>
      cv_status wait_until(Lock& lock, const chrono::time_point<Clock, Duration>& abs_time);
    template<class Lock, class Clock, class Duration, class Predicate>
      bool wait_until(Lock& lock, const chrono::time_point<Clock, Duration>& abs_time,
                      Predicate pred);
    template<class Lock, class Rep, class Period>
      cv_status wait_for(Lock& lock, const chrono::duration<Rep, Period>& rel_time);
    template<class Lock, class Rep, class Period, class Predicate>
      bool wait_for(Lock& lock, const chrono::duration<Rep, Period>& rel_time, Predicate pred);

\end{codeblock}
{\color{insertcolor}
\begin{codeblock}
    // \ref{thread.condvarany.interruptwait} \tcode{interrupt_token} waits:
    template <class Lock, class Predicate>
      bool wait_until(Lock& lock,
                      Predicate pred,
                      interrupt_token itoken);
    template <class Lock, class Clock, class Duration, class Predicate>
      bool wait_until(Lock& lock,
                      const chrono::time_point<Clock, Duration>& abs_time
                      Predicate pred,
                      interrupt_token itoken);
    template <class Lock, class Rep, class Period, class Predicate>
      bool wait_for(Lock& lock,
                    const chrono::duration<Rep, Period>& rel_time,
                    Predicate pred,
                    interrupt_token itoken);
\end{codeblock}
}
\begin{codeblock}
  };
}
\end{codeblock}


\indexlibrary{\idxcode{condition_variable_any}!constructor}%
\begin{itemdecl}
condition_variable_any();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an object of type \tcode{condition_variable_any}.

\pnum
\throws \tcode{bad_alloc} or \tcode{system_error} when an exception is
required\iref{thread.req.exception}.

\pnum
\errors
\begin{itemize}
\item \tcode{resource_unavailable_try_again} --- if some non-memory resource
limitation prevents initialization.

\item \tcode{operation_not_permitted} --- if the thread does not have the
privilege to perform the operation.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{condition_variable_any}!destructor}%
\begin{itemdecl}
~condition_variable_any();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires There shall be no thread blocked on \tcode{*this}. \begin{note} That is, all
threads shall have been notified; they may subsequently block on the lock specified in the
wait.
This relaxes the usual rules, which would have required all wait calls to happen before
destruction. Only the notification to unblock the wait needs to happen before destruction.
The user should take care to ensure that no threads wait on \tcode{*this} once the destructor has
been started, especially when the waiting threads are calling the wait functions in a loop or
using the overloads of \tcode{wait}, \tcode{wait_for}, or \tcode{wait_until} that take a predicate.
\end{note}

\pnum\effects Destroys the object.
\end{itemdescr}

\indexlibrarymember{notify_one}{condition_variable_any}%
\begin{itemdecl}
void notify_one() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects If any threads are blocked waiting for \tcode{*this}, unblocks one of those threads.
\end{itemdescr}

\indexlibrarymember{notify_all}{condition_variable_any}%
\begin{itemdecl}
void notify_all() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum\effects Unblocks all threads that are blocked waiting for \tcode{*this}.
\end{itemdescr}


%**************************************
%*** wait functions:

{\color{insertcolor}
\rSec3[thread.condvarany.wait]{Noninterruptable waits}
}

% wait(Lock)
\indexlibrarymember{wait}{condition_variable_any}%
\begin{itemdecl}
template<class Lock>
  void wait(Lock& lock);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{itemize}
\item Atomically calls \tcode{lock.unlock()} and blocks on \tcode{*this}.
\item When unblocked, calls \tcode{lock.lock()} (possibly blocking on the lock) and returns.
\item The function will unblock when signaled by a call to \tcode{notify_one()},
a call to \tcode{notify_all()}, or spuriously.
\end{itemize}

\pnum
\remarks
If the function fails to meet the postcondition, \tcode{terminate()}
shall be called\iref{except.terminate}.
\begin{note} This can happen if the re-locking of the mutex throws an exception. \end{note}

\pnum\postconditions \tcode{lock} is locked by the calling thread.

\pnum\throws Nothing.

\end{itemdescr}


% wait(Lock, Predicate)
\indexlibrarymember{wait}{condition_variable_any}%
\begin{itemdecl}
template<class Lock, class Predicate>
  void wait(Lock& lock, Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
while (!pred())
  wait(lock);
\end{codeblock}
\end{itemdescr}


% wait_until(Lock, Timepoint)
\indexlibrarymember{wait_until}{condition_variable_any}%
\begin{itemdecl}
template<class Lock, class Clock, class Duration>
  cv_status wait_until(Lock& lock, const chrono::time_point<Clock, Duration>& abs_time);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects

\begin{itemize}
\item
Atomically calls \tcode{lock.unlock()} and blocks on \tcode{*this}.

\item
When unblocked, calls \tcode{lock.lock()} (possibly blocking on the lock) and returns.

\item
The function will unblock when signaled by a call to \tcode{notify_one()}, a call to \tcode{notify_all()},
expiration of the absolute timeout\iref{thread.req.timing} specified by \tcode{abs_time},
or spuriously.

\item
If the function exits via an exception, \tcode{lock.lock()} shall be called prior to exiting the function.
\end{itemize}

\pnum
\remarks
If the function fails to meet the postcondition, \tcode{terminate()}
shall be called\iref{except.terminate}.
\begin{note} This can happen if the re-locking of the mutex throws an exception. \end{note}

\pnum
\postconditions \tcode{lock} is locked by the calling thread.

\pnum
\returns \tcode{cv_status::timeout} if
the absolute timeout\iref{thread.req.timing} specified by \tcode{abs_time} expired,
otherwise \tcode{cv_status::no_timeout}.

\pnum
\throws Timeout-related
exceptions\iref{thread.req.timing}.

\end{itemdescr}

\indexlibrarymember{wait_for}{condition_variable_any}%
\begin{itemdecl}
template<class Lock, class Rep, class Period>
  cv_status wait_for(Lock& lock, const chrono::duration<Rep, Period>& rel_time);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return wait_until(lock, chrono::steady_clock::now() + rel_time);
\end{codeblock}

\pnum
\returns \tcode{cv_status::timeout} if
the relative timeout\iref{thread.req.timing} specified by \tcode{rel_time} expired,
otherwise \tcode{cv_status::no_timeout}.

\pnum
\remarks
If the function fails to meet the postcondition, \tcode{terminate()}
shall be called\iref{except.terminate}.
\begin{note} This can happen if the re-locking of the mutex throws an exception. \end{note}

\pnum
\postconditions \tcode{lock} is locked by the calling thread.

\pnum
\throws Timeout-related
exceptions\iref{thread.req.timing}.

\end{itemdescr}

\indexlibrarymember{wait_until}{condition_variable_any}%
\begin{itemdecl}
template<class Lock, class Clock, class Duration, class Predicate>
  bool wait_until(Lock& lock, const chrono::time_point<Clock, Duration>& abs_time, Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
while (!pred())
  if (wait_until(lock, abs_time) == cv_status::timeout)
    return pred();
return true;
\end{codeblock}

\pnum
\begin{note} There is no blocking if \tcode{pred()} is initially \tcode{true}, or
if the timeout has already expired. \end{note}

\pnum
\begin{note} The returned value indicates whether the predicate evaluates to \tcode{true}
regardless of whether the timeout was triggered. \end{note}
\end{itemdescr}

\indexlibrarymember{wait_for}{condition_variable_any}%
\begin{itemdecl}
template<class Lock, class Rep, class Period, class Predicate>
  bool wait_for(Lock& lock, const chrono::duration<Rep, Period>& rel_time, Predicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));
\end{codeblock}
\end{itemdescr}



\clearpage

%**********************************************************
%\begin{codeblock}
%******************
%* NEW:
%******************
%\end{codeblock}
{\color{insertcolor}

%    template <class Lock, class Predicate>
%      bool wait_until(Lock& lock,
%                      Predicate pred,
%                      interrupt_token itoken);
%    template <class Lock, class Clock, class Duration, class Predicate>
%      bool wait_until(Lock& lock,
%                      const chrono::time_point<Clock, Duration>& abs_time
%                      Predicate pred,
%                      interrupt_token itoken);
%    template <class Lock, class Rep, class Period, class Predicate>
%      bool wait_for(Lock& lock,
%                    const chrono::duration<Rep, Period>& rel_time,
%                    Predicate pred,
%                    interrupt_token itoken);

%**************************************
\rSec3[thread.condvarany.interruptwait]{Interruptable waits}

The following functions ensure to get notified
if an interrupt is signaled for the passed \tcode{interrupt_token}.
In that case they return
(returning \tcode{false} if the predicate evaluates to \tcode{false}). 
\begin{note} 
        Because all signatures here call
        \tcode{interrupted()}, their calls synchronize with \tcode{interrupt()}.
      \end{note}

% Hans Boehm:
%We then also need some statement for the waiting functions that if they return with an interrupted status, their synchronization behavior is as though they called interrupted().
%{\color{blue}
%[{\itshape{}Editorial note:} Because all signatures here in the effects clause call
%        \tcode{interrupted()}, we don't need wording
%        that the calls synchronize with \tcode{interrupt()}. ]
%}


%**** untimed wait_until (with pred)
% return false if itoken.interrupted():

\begin{itemdecl}
template <class Lock, class Predicate>
  bool wait_until(Lock& lock,
                  Predicate pred,
                  interrupt_token itoken);
\end{itemdecl}
%{\color{blue}
%[{\itshape{}Editorial note:} {\color{diffcolor}This color signals differences to the corresponding \tcode{wait()} function without the interrupt token parameter.} ]
%}

\begin{itemdescr}

%{\color{diffcolor}
 \pnum\effects Registers \tcode{*this} to get notified when an interrupt is signaled on \tcode{itoken}
                during this call and then equivalent to:
\begin{codeblock}
while(!pred() && !itoken.interrupted()) {
  wait(lock, [&pred, &itoken] {
                return pred() || itoken.interrupted();
             });
}
return pred();
\end{codeblock}

 \pnum \begin{note} The returned value indicates whether the predicate evaluated to
        \tcode{true} regardless of whether
        an interrupt was signaled. \end{note}

 \pnum \postconditions Exception or \tcode{lock} is locked by the calling thread.

 \pnum \remarks
        If the function fails to meet the postcondition, \tcode{terminate()}
        shall be called\iref{except.terminate}.
        \begin{note} This can happen if the re-locking of the mutex throws an exception. \end{note}

 \pnum \throws 
        \tcode{std::bad_alloc} if memory for the internal data structures could not be allocated, or
        any exception thrown by \tcode{pred}.

%}%diffcolor

\end{itemdescr}



%**** wait_until (with pred)
% return false if itoken.interrupted():

\begin{itemdecl}
template <class Lock, class Clock, class Duration, class Predicate>
  bool wait_until(Lock& lock,
                  const chrono::time_point<Clock, Duration>& abs_time
                  Predicate pred,
                  interrupt_token itoken);
\end{itemdecl}
%{\color{blue}
%[{\itshape{}Editorial note:} {\color{diffcolor}This color signals differences to the corresponding \tcode{wait_until()} function without the interrupt token parameter.} ]
%}

\begin{itemdescr}
 \pnum\effects Registers \tcode{*this} to get notified when an interrupt is signaled on \tcode{itoken}
                during this call and then equivalent to:
\begin{codeblock}
while(!pred() && !itoken.interrupted() && Clock::now() < abs_time) {
  cv.wait_until(lock,
                abs_time,
                [&pred, &itoken] {
                  return pred() || itoken.interrupted();
                });
}
return pred();
\end{codeblock}

\pnum
\begin{note} There is no blocking if \tcode{pred()} is initially \tcode{true}, 
itoken is not valid or already interrupted, or
if the timeout has already expired. \end{note}

\pnum
\begin{note} The returned value indicates whether the predicate evaluates to \tcode{true}
regardless of whether the timeout was triggered. \end{note}

 \pnum \begin{note} The returned value indicates whether the predicate evaluated to
        \tcode{true} regardless of whether the timeout was triggered
        or an interrupt was signaled. \end{note}

 \pnum \postconditions Exception or \tcode{lock} is locked by the calling thread.

 \pnum \remarks
        If the function fails to meet the postcondition, \tcode{terminate()}
        shall be called\iref{except.terminate}.
        \begin{note} This can happen if the re-locking of the mutex throws an exception. \end{note}

 \pnum \throws 
        \tcode{std::bad_alloc} if memory for the internal data structures could not be allocated,
        any timeout-related exception\iref{thread.req.timing},
        or any exception thrown by \tcode{pred}.

%{\color{diffcolor}
% \pnum\sync If the function returns with an interrupted status, 
%                their synchronization behavior is as though it called \tcode{interrupted()}.
%}%diffcolor
\end{itemdescr}


%**** wait_for (with pred)
% return false if itoken.interrupted():

\begin{itemdecl}
template <class Lock, class Rep, class Period, class Predicate>
  bool wait_for(Lock& lock,
                const chrono::duration<Rep, Period>& rel_time,
                Predicate pred,
                interrupt_token itoken);
\end{itemdecl}
%{\color{blue}
%[{\itshape{}Editorial note:} {\color{diffcolor}This color signals differences to the corresponding \tcode{wait_for()} function without the interrupt token parameter.} ]
%}
\begin{itemdescr}
 \pnum \effects Equivalent to:
\begin{codeblock}
return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred), std::move(itoken));
\end{codeblock}
\end{itemdescr}

}%\color{insertcolor}


\vspace{5ex}

%******************************************************************
\rSec1[futures]{Futures}

...

